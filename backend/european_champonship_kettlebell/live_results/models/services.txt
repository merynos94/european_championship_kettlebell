"""Service functions for business logic related to models."""
# W pliku services.py

from typing import TYPE_CHECKING
from django.db.models import Case, F, FloatField, Value, When # Upewnij się, że te importy są
from django.db.models.functions import Greatest             # na górze pliku services.py
# ... (inne importy na górze pliku) ...
from .constants import KB_SQUAT, ONE_KB_PRESS, PISTOL_SQUAT, SEE_SAW_PRESS, SNATCH, TGU, TWO_KB_PRESS
# Importuj modele wyników, które są używane w discipline_models_map
from .results.kb_squat import KBSquatResult
from .results.one_kettlebell_press import OneKettlebellPressResult
from .results.pistol_squat import PistolSquatResult
from .results.see_saw_press import SeeSawPressResult
from .results.snatch import SnatchResult
from .results.tgu import TGUResult
from .results.two_kettlebell_press import TwoKettlebellPressResult
from .results.overall import OverallResult
# Importy potrzebne tylko do type hinting
if TYPE_CHECKING:
    from .category import Category
    from .player import Player


def update_discipline_positions(category: "Category") -> None:
    """
    Calculates and updates the position for each player within a category
    for every active discipline in that category.
    TGU is ranked based on max_weight / body_weight.
    """
    # Import Player *wewnątrz* funkcji, aby uniknąć problemów z importem kołowym
    from .player import Player

    players_in_category = Player.objects.filter(categories=category)
    # Sprawdź, czy są jacyś gracze w kategorii, aby uniknąć niepotrzebnych zapytań
    if not players_in_category.exists():
        print(f"INFO: Brak graczy w kategorii {category.id}, pomijam update_discipline_positions.")
        return

    disciplines = category.get_disciplines()
    if not disciplines:
        print(f"INFO: Brak aktywnych dyscyplin w kategorii {category.id}, pomijam update_discipline_positions.")
        return

    discipline_models_map = {
        SNATCH: SnatchResult,
        TGU: TGUResult,
        SEE_SAW_PRESS: SeeSawPressResult,
        KB_SQUAT: KBSquatResult,
        PISTOL_SQUAT: PistolSquatResult,
        ONE_KB_PRESS: OneKettlebellPressResult,
        TWO_KB_PRESS: TwoKettlebellPressResult,
    }

    # Define scoring fields/annotations for ordering
    ordering_logic = {
        SNATCH: "-result",
        TGU: "-tgu_bw_ratio",  # ZMIENIONO: Sortuj wg stosunku do wagi ciała
        PISTOL_SQUAT: "-max_pistol_result", # Zostawiono max_result (lub zmień jeśli trzeba)
        ONE_KB_PRESS: "-max_okbp_result",   # Zostawiono max_result (lub zmień jeśli trzeba)
        SEE_SAW_PRESS: "-max_ssp_score",
        KB_SQUAT: "-max_kbs_score",
        TWO_KB_PRESS: "-max_tkbp_score",
    }

    print(f"INFO: Rozpoczynam aktualizację pozycji dla kategorii {category.id} ({category.name})") # Dodatkowy log
    for discipline in disciplines:
        if discipline not in discipline_models_map:
            print(f"OSTRZEŻENIE: Pominięto nieznaną dyscyplinę '{discipline}' w update_discipline_positions dla kategorii {category.id}")
            continue

        model = discipline_models_map[discipline]
        order_by_field = ordering_logic.get(discipline) # Użyj .get() dla bezpieczeństwa

        if not order_by_field:
             print(f"OSTRZEŻENIE: Brak logiki sortowania dla dyscypliny '{discipline}' w update_discipline_positions dla kategorii {category.id}")
             continue

        print(f"--- INFO: Przetwarzam dyscyplinę: {discipline} dla kategorii {category.id} ---")

        # Pobierz wyniki RAZEM Z GRACZEM (i jego wagą) za pomocą select_related
        # Filtruj tylko istniejące wyniki dla graczy w kategorii
        results_qs = model.objects.select_related('player').filter(player__in=players_in_category)

        # Dodaj adnotacje
        if discipline == TGU:
            results_qs = results_qs.annotate(
                max_tgu_result=Greatest("result_1", "result_2", "result_3")
            ).annotate(
                tgu_bw_ratio=Case(
                    When(player__weight__isnull=False, player__weight__gt=0,
                         then=(F('max_tgu_result') / F('player__weight'))), # Ratio
                    default=Value(0.0),
                    output_field=FloatField()
                )
            )
        elif discipline == PISTOL_SQUAT:
             # TODO: Jeśli Pistol też ma być wg %BW, dodaj tu adnotację 'pistol_bw_ratio'
             results_qs = results_qs.annotate(max_pistol_result=Greatest("result_1", "result_2", "result_3"))
        elif discipline == ONE_KB_PRESS:
             # TODO: Jeśli OKBP też ma być wg %BW, dodaj tu adnotację 'okbp_bw_ratio'
             results_qs = results_qs.annotate(max_okbp_result=Greatest("result_1", "result_2", "result_3"))
        elif discipline == SEE_SAW_PRESS:
            results_qs = results_qs.annotate(
                ssp_score_1=Case(When(result_left_1__gt=0, result_right_1__gt=0, then=F('result_left_1') + F('result_right_1')), default=Value(0.0), output_field=FloatField()),
                ssp_score_2=Case(When(result_left_2__gt=0, result_right_2__gt=0, then=F('result_left_2') + F('result_right_2')), default=Value(0.0), output_field=FloatField()),
                ssp_score_3=Case(When(result_left_3__gt=0, result_right_3__gt=0, then=F('result_left_3') + F('result_right_3')), default=Value(0.0), output_field=FloatField()),
            ).annotate(max_ssp_score=Greatest('ssp_score_1', 'ssp_score_2', 'ssp_score_3'))
        elif discipline == KB_SQUAT:
             results_qs = results_qs.annotate(
                kbs_score_1=Case(When(result_left_1__gt=0, result_right_1__gt=0, then=F('result_left_1') + F('result_right_1')), default=Value(0.0), output_field=FloatField()),
                kbs_score_2=Case(When(result_left_2__gt=0, result_right_2__gt=0, then=F('result_left_2') + F('result_right_2')), default=Value(0.0), output_field=FloatField()),
                kbs_score_3=Case(When(result_left_3__gt=0, result_right_3__gt=0, then=F('result_left_3') + F('result_right_3')), default=Value(0.0), output_field=FloatField()),
            ).annotate(max_kbs_score=Greatest('kbs_score_1', 'kbs_score_2', 'kbs_score_3'))
        elif discipline == TWO_KB_PRESS:
             results_qs = results_qs.annotate(
                 tkbp_score_1=Case(When(result_left_1__gt=0, result_right_1__gt=0, then=F('result_left_1') + F('result_right_1')), default=Value(0.0), output_field=FloatField()),
                 tkbp_score_2=Case(When(result_left_2__gt=0, result_right_2__gt=0, then=F('result_left_2') + F('result_right_2')), default=Value(0.0), output_field=FloatField()),
                 tkbp_score_3=Case(When(result_left_3__gt=0, result_right_3__gt=0, then=F('result_left_3') + F('result_right_3')), default=Value(0.0), output_field=FloatField()),
             ).annotate(max_tkbp_score=Greatest('tkbp_score_1', 'tkbp_score_2', 'tkbp_score_3'))
        # Dla SNATCH nie potrzebujemy dodatkowych adnotacji, sortujemy po polu 'result'

        # Sortuj wyniki
        # Używamy klucza z ordering_logic, np. "-tgu_bw_ratio"
        ordered_results = results_qs.order_by(order_by_field, "player__surname", "player__name")

        # Zaktualizuj pozycje
        updates = []
        current_pos = 0
        last_score = None # Używane do obsługi remisów
        rank_counter = 0
        for result in ordered_results:
            rank_counter += 1
            score = None # Resetuj score
            try:
                if discipline == SNATCH: score = result.result
                elif discipline == TGU: score = result.tgu_bw_ratio # ZMIENIONO: Użyj nowej adnotacji
                elif discipline == PISTOL_SQUAT: score = result.max_pistol_result # TODO: Zmień na %BW jeśli trzeba
                elif discipline == ONE_KB_PRESS: score = result.max_okbp_result # TODO: Zmień na %BW jeśli trzeba
                elif discipline == SEE_SAW_PRESS: score = result.max_ssp_score
                elif discipline == KB_SQUAT: score = result.max_kbs_score
                elif discipline == TWO_KB_PRESS: score = result.max_tkbp_score
            except AttributeError as e:
                print(f"OSTRZEŻENIE: Brak atrybutu wyniku dla {discipline} u gracza {getattr(result, 'player_id', 'N/A')} ({e}). Ustawiam score na None.")
                score = None

            # Obsługa sytuacji, gdy nie ma wyniku (score is None) lub jest 0.0
            # Porównujemy tylko jeśli aktualny score nie jest None
            score_for_comparison = score if score is not None else -99999.0
            last_score_for_comparison = last_score if last_score is not None else -99999.0

            if score_for_comparison != last_score_for_comparison:
                 # Jeśli aktualny score jest None LUB różny od poprzedniego, resetuj pozycję
                 current_pos = rank_counter
                 last_score = score # Zapisz aktualny score (może być None)

            # Przypisz pozycję tylko jeśli score nie jest None (lub jeśli chcesz przypisać pozycję nawet przy braku wyniku)
            # W tym przypadku przypisujemy pozycję zawsze, nawet jeśli score to 0.0 lub None, zgodnie z logiką rank_counter
            if result.position != current_pos:
                result.position = current_pos
                updates.append(result)

        # Zapisz zmiany pozycji zbiorczo
        if updates:
            try:
                model.objects.bulk_update(updates, ["position"])
                print(f"INFO: Zaktualizowano {len(updates)} pozycji dla dyscypliny {discipline} w kategorii {category.id}")
            except Exception as e_bulk:
                # Użyj self? Nie, jesteśmy w funkcji, nie w metodzie klasy
                # print(f"!!!!!!!!!! BŁĄD Player {self.id}: Błąd podczas bulk_update pozycji dla {discipline}: {e_bulk} !!!!!!!!!!!")
                print(f"!!!!!!!!!! BŁĄD: Błąd podczas bulk_update pozycji dla {discipline} w kat. {category.id}: {e_bulk} !!!!!!!!!!!")

    print(f"INFO: Zakończono aktualizację pozycji dla kategorii {category.id} ({category.name})")

# --- Pozostałe funkcje w services.py (update_overall_results_for_category, update_overall_results_for_player) ---
# Pozostają bez zmian, ponieważ używają już zapisanej wartości 'position' z modeli wyników.
# Upewnij się, że są one obecne w Twoim pliku.


def update_overall_results_for_category(category: "Category") -> None:
    """
    Calculates and updates overall scores and final positions for all players
    within a specific category based on their discipline positions.
    """
    from .player import Player # Import Player do użycia w funkcji

    players_in_category = Player.objects.filter(categories=category).prefetch_related(
        "snatch_result",
        "tgu_result",
        "pistol_squat_result",
        "see_saw_press_result",
        "kb_squat_result",
        "one_kettlebell_press_result",
        "two_kettlebell_press_result",
    )
    disciplines = category.get_disciplines()

    overall_updates = []

    # 1. Calculate points based on position in each active discipline
    for player in players_in_category:
        # ... (reszta logiki obliczania punktów bez zmian) ...
        overall_result, created = OverallResult.objects.get_or_create(player=player)

        # Reset points
        overall_result.snatch_points = 0.0
        overall_result.tgu_points = 0.0
        overall_result.see_saw_press_points = 0.0
        overall_result.kb_squat_points = 0.0
        overall_result.pistol_squat_points = 0.0
        overall_result.one_kb_press_points = 0.0
        overall_result.two_kb_press_points = 0.0
        overall_result.tiebreak_points = -0.5 if player.tiebreak else 0.0

        # Assign points based on position
        # ... (przypisywanie punktów) ...
        if SNATCH in disciplines and hasattr(player, "snatch_result") and player.snatch_result.position is not None:
            overall_result.snatch_points = float(player.snatch_result.position)
        if TGU in disciplines and hasattr(player, "tgu_result") and player.tgu_result.position is not None:
            overall_result.tgu_points = float(player.tgu_result.position)
        if (
            SEE_SAW_PRESS in disciplines
            and hasattr(player, "see_saw_press_result")
            and player.see_saw_press_result.position is not None
        ):
            overall_result.see_saw_press_points = float(player.see_saw_press_result.position)
        if (
            KB_SQUAT in disciplines
            and hasattr(player, "kb_squat_result")
            and player.kb_squat_result.position is not None
        ):
            overall_result.kb_squat_points = float(player.kb_squat_result.position)
        if (
            PISTOL_SQUAT in disciplines
            and hasattr(player, "pistol_squat_result")
            and player.pistol_squat_result.position is not None
        ):
            overall_result.pistol_squat_points = float(player.pistol_squat_result.position)
        if (
            ONE_KB_PRESS in disciplines
            and hasattr(player, "one_kettlebell_press_result")
            and player.one_kettlebell_press_result.position is not None
        ):
            overall_result.one_kb_press_points = float(player.one_kettlebell_press_result.position)
        if (
            TWO_KB_PRESS in disciplines
            and hasattr(player, "two_kettlebell_press_result")
            and player.two_kettlebell_press_result.position is not None
        ):
            overall_result.two_kb_press_points = float(player.two_kettlebell_press_result.position)

        overall_result.calculate_total_points()
        overall_updates.append(overall_result)

    # Bulk update points
    if overall_updates:
        OverallResult.objects.bulk_update(
            overall_updates,
            [
                "snatch_points",
                "tgu_points",
                "see_saw_press_points",
                "kb_squat_points",
                "pistol_squat_points",
                "one_kb_press_points",
                "two_kb_press_points",
                "tiebreak_points",
                "total_points",
            ],
        )

    # 2. Determine final positions
    # ... (logika obliczania final_position bez zmian) ...
    final_results = OverallResult.objects.filter(player__in=players_in_category).order_by(
        "total_points", "player__surname", "player__name"
    )

    final_pos_updates = []
    current_final_pos = 0
    last_total_points = None
    rank_counter = 0
    for result in final_results:
        rank_counter += 1
        if result.total_points != last_total_points:
            current_final_pos = rank_counter
            last_total_points = result.total_points

        if result.final_position != current_final_pos:
            result.final_position = current_final_pos
            final_pos_updates.append(result)

    if final_pos_updates:
        OverallResult.objects.bulk_update(final_pos_updates, ["final_position"])


def update_overall_results_for_player(player: "Player") -> None:
    """Updates overall results for all categories the player belongs to."""
    # Należy zaktualizować pozycje we wszystkich kategoriach gracza
    # i przeliczyć wyniki ogólne dla tych kategorii.
    for category in player.categories.all():
        # Najpierw zaktualizuj pozycje w dyscyplinach dla całej kategorii
        update_discipline_positions(category)
        # Następnie zaktualizuj wyniki ogólne dla całej kategorii
        update_overall_results_for_category(category)
